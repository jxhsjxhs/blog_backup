---
title: 系统负载
date: 2019-07-22 22:18:27
categories: 系统
tags: 负载
---

## 负载变高有三个原因：

>1.CPU 密集型进程，使用大量 CPU 会知道平均负载升高。
>2.I/O 密集型进程，等到 I/O 也会导致平均负载升高，但是 CPU 使用率不一定很高。 3.大量等待 CPU 的进程调度也会导致平均负载升高，此时 CPU 使用率也会比较高。


<center> iostat mpstat pidstat vmstat perf top</center>


### mpstat

>mpstat -P ALL 5
>作用查看 cpu 每个 cpu 使用情况


### pidstat

>pidstat -u 5 1
>实时查看进程的 CPU、内存、I/O 以及上下文切换等性能指标


### vmstat

>vmstat 1
>查看 系统内存和上下文切换以及切换类型的工具


>举例：
>发现系统负载变高时候 1.使用 mpstat -P ALL 5
>发现是使用率为百分之百 但是 iowait 为 0 说明此时真的有程序使用了百分之百的 CPU，这次负载升高就是此原因

>2.使用 mpstat -P ALL 5
>发现系统 CPU 使用率只有百分之 20 多 但是 系统的 iowait 达到了百分之 70 多 这说明这次负载升高是由于 iowait 引起的
>然后使用 pidstat -u 5 1


## CPU 性能

>1.多任务竞争 CPU，cpu 变换任务的时候进行 CPU 上下文切换(context switch)。CPU 执行任务有 4 种方式：进程、线程、或者硬件通过触发信号导致中断的调用。
>2、当切换任务的时候，需要记录任务当前的状态和获取下一任务的信息和地址(指针)，这就是上下文的内容。因此，上下文是指某一时间点 CPU 寄存器(CPU register)和程序计数器(PC)的内容, 广义上还包括内存中进程的虚拟地址映射信息.
>3、上下文切换的过程：
>(1)记录当前任务的上下文(即寄存器和计算器等所有的状态)；
>(2)找到新任务的上下文并加载；
>(3)切换到新任务的程序计算器位置，恢复其任务。
>4、根据任务的执行形式，相应的下上文切换，有进程上下文切换、线程上下文切换、以及中断上下文切换三类。
>5、进程和线程的区别：
>进程是资源分配和执行的基本单位；线程是任务调度和运行的基本单位。线程没有资源，进程给指针提供虚拟内存、栈、变量等共享资源，而线程可以共享进程的资源。
>6、进程上下文切换：是指从一个进程切换到另一个进程。
>(1)进程运行态为内核运行态和进程运行态。内核空间态资源包括内核的堆栈、寄存器等；用户空间态资源包括虚拟内存、栈、变量、正文、数据等
>(2)系统调用(软中断)在内核态完成的，需要进行 2 次 CPU 上下文切换(用户空间-->内核空间-->用户空间)，不涉及用户态资源，也不会切换进程
>(3)进程是由内核来管理和调度的，进程的切换只能发生在内核态。所以，进程的上下文不仅包括了用户空间的资源，也包括内核空间资源。
>(4)进程的上下文切换过程：
>(a)接收到切换信号，挂起进程，记录当前进程的虚拟内存、栈等资源存储;
>(b)将这个进程在 CPU 中的上下文状态存储于起来;
>(c)然后在内存中检索下一个进程的上下文;
>(d)并将其加载到 CPU 的寄存器中恢复;
>(e)还需要刷新进程的虚拟内存和用户栈;
>(f)最后跳转到程序计数器所指向的位置（即跳转到进程被中断时的代码行），以恢复该进程。
>(5)、下列将会触发进程上下文切换的场景：
>(a)、根据调度策略，将 CPU 时间划片为对应的时间片，当时间片耗尽，当前进程必须挂起。
>(b)、资源不足的，在获取到足够资源之前进程挂起。
>(c)、进程 sleep 挂起进程。
>(d)、高优先级进程导致当前进度挂起
>(e)、硬件中断，导致当前进程挂起
>7、线程上下文切换：
>(1)、不通进程之间的线程上下文切换，其过程和进程上下文切换大致相同。
>(2)、进程内部的线程进上下文切换。不需要切换进程的用户资源，只需要切换线程私有的数据和寄存器等。这会比进程上下文进程切换消耗的资源少，所以多线程相比多进程的优势。
>8、中断上下文切换
>快速响应硬件的事件，中断处理会打断进程的正常调度和执行。同一 CPU 内，硬件中断优先级高于进程。切换过程类似于系统调用的时候，不涉及到用户运行态资源。但大量的中断上下文切换同样可能引发性能问题。

### 排查 cpu 负载


>1.用户 CPU 和 Nice CPU 高，说明用户态进程占用了较多的 CPU，所以应该着重排查进程的性能问题。
>2.系统 CPU 高，说明内核态占用了较多的 CPU，所以应该着重排查内核线程或者系统调用的性能问题。
>3.I/O 等待 CPU 高，说明等待 I/O 的时间比较长，所以应该着重排查系统存储是不是出现了 I/O 问题。 
>4.软中断和硬中断高，说明软中断或硬中断的处理程序占用了较多的 CPU，所以应该着重排查内核中的中断服务程序。


## 排查方法
>如果应用方说系统负载卡 1.首先看看系统平均负载，1 分钟 5 分钟 15 分钟 查看趋势 2.如果平均负载高，先判断是 io 导致，还是 cpu 导致或者是中断导致
>用 top 查看 看看哪个方面的比较高 或者 mpstat -p ALL 5
>如果是 io 导致:
>用 iotop iostat 判断是哪个程序 io 比较频繁，或者读写次数特别多，从而进一步分析
>如果是 cpu 比较高导致:
>用 ps -ef 或者 top -U 或者 pidstat 查看哪个进程导致的 cpu 较高，从而进一步分析
>如果是中断高可以看到
>如果只看到负载高 但是看不到其他的任何异常，那么用神器 perf top (perf record -g [and] perf report)
